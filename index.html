<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Sudoku</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- PWA / iPhone -->
  <meta name="theme-color" content="#2563eb" />
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(135deg, #eef2ff, #e0f7fa);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app {
      background: #ffffff;
      padding: 16px 20px 20px;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      max-width: 430px;
      width: 100%;
    }

    h1 {
      margin: 0;
      font-size: 1.5rem;
      text-align: center;
    }

    .subtitle {
      margin: 4px 0 0;
      text-align: center;
      font-size: 0.9rem;
      color: #555;
    }

    #sudoku-grid {
      margin: 16px auto 10px;
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
      gap: 2px;
      justify-content: center;
    }

    #sudoku-grid input.cell {
      width: 40px;
      height: 40px;
      text-align: center;
      font-size: 20px;
      border: 1px solid #ccc;
      outline: none;
      border-radius: 4px;
      transition: background 0.15s, border-color 0.15s, box-shadow 0.15s;
      caret-color: transparent; /* ingen textmark√∂r */
    }

    #sudoku-grid input.cell.given {
      background: #eef3ff;
      font-weight: 600;
      color: #1f2933;
    }

    #sudoku-grid input.cell.error {
      background: #ffe5e5;
      border-color: #f97373;
    }

    #sudoku-grid input.cell.box-bottom {
      border-bottom: 2px solid #111827;
    }

    #sudoku-grid input.cell.box-right {
      border-right: 2px solid #111827;
    }

    #sudoku-grid input.cell.selected {
      border-color: #10b981;
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.4);
    }

    .difficulty {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      align-items: center;
      font-size: 0.85rem;
      color: #374151;
    }

    .difficulty span {
      font-weight: 500;
    }

    .difficulty label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .keypad {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px;
      justify-items: center;
    }

    .keypad button {
      width: 100%;
      padding: 8px 0;
      border-radius: 999px;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      background: #e5e7eb;
      color: #111827;
      font-weight: 500;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s, opacity 0.15s;
    }

    .keypad button.num-key {
      background: #f3f4ff;
    }

    .keypad button.clear-key {
      background: #fee2e2;
    }

    .keypad button.disabled {
      opacity: 0.35;
      cursor: default;
      pointer-events: none;
      box-shadow: none;
    }

    .keypad button:hover:not(.disabled) {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12);
    }

    .keypad button:active:not(.disabled) {
      transform: translateY(0);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.18);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 12px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #2563eb;
      color: #fff;
      font-weight: 500;
      box-shadow: 0 3px 8px rgba(37, 99, 235, 0.3);
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
    }

    .btn.secondary {
      background: #e5e7eb;
      color: #111827;
      box-shadow: none;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 12px rgba(37, 99, 235, 0.35);
    }

    .btn.secondary:hover {
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 5px rgba(37, 99, 235, 0.25);
    }

    .status {
      margin-top: 10px;
      text-align: center;
      font-size: 0.9rem;
      min-height: 1.2em;
      color: #111827;
    }

    .footer {
      margin-top: 8px;
      text-align: center;
      font-size: 0.75rem;
      color: #6b7280;
    }

    @media (max-width: 480px) {
      #sudoku-grid {
        grid-template-columns: repeat(9, 32px);
        grid-template-rows: repeat(9, 32px);
      }

      #sudoku-grid input.cell {
        width: 32px;
        height: 32px;
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Sudoku</h1>
    <p class="subtitle">Fyll i siffrorna 1‚Äì9 s√• att varje rad, kolumn och 3√ó3-ruta blir komplett.</p>

    <div id="sudoku-grid"></div>

    <div class="difficulty">
      <span>Sv√•righetsgrad:</span>
      <label>
        <input type="radio" name="difficulty" value="latt" />
        L√§tt
      </label>
      <label>
        <input type="radio" name="difficulty" value="medel" checked />
        Medel
      </label>
      <label>
        <input type="radio" name="difficulty" value="svar" />
        Sv√•r
      </label>
    </div>

    <div class="keypad" id="keypad">
      <button class="num-key" data-num="1">1</button>
      <button class="num-key" data-num="2">2</button>
      <button class="num-key" data-num="3">3</button>
      <button class="num-key" data-num="4">4</button>
      <button class="num-key" data-num="5">5</button>
      <button class="num-key" data-num="6">6</button>
      <button class="num-key" data-num="7">7</button>
      <button class="num-key" data-num="8">8</button>
      <button class="num-key" data-num="9">9</button>
      <button class="clear-key" data-clear="true">Rensa</button>
    </div>

    <div class="controls">
      <button class="btn" id="btn-check">Kontrollera</button>
      <button class="btn secondary" id="btn-new">Ny sudoku</button>
      <button class="btn secondary" id="btn-solution">Visa l√∂sning</button>
    </div>

    <p class="status" id="status"></p>
    <div class="footer">Skapad av JL</div>
  </div>

  <script>
    const GRID_SIZE = 9;

    const gridElement = document.getElementById("sudoku-grid");
    const statusElement = document.getElementById("status");
    const keypadElement = document.getElementById("keypad");

    let currentPuzzle = null;
    let currentSolution = null;
    let selectedIndex = null;

    const difficultySettings = {
      latt: 18,
      medel: 30,
      svar: 42
    };

    function getSelectedDifficulty() {
      const radio = document.querySelector('input[name="difficulty"]:checked');
      return radio ? radio.value : "medel";
    }

    // ---------- Sudokuhj√§lp ----------

    function createEmptyBoard() {
      return Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function isSafe(board, row, col, num) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (board[row][c] === num) return false;
      }
      for (let r = 0; r < GRID_SIZE; r++) {
        if (board[r][col] === num) return false;
      }
      const boxRow = Math.floor(row / 3) * 3;
      const boxCol = Math.floor(col / 3) * 3;
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (board[boxRow + r][boxCol + c] === num) return false;
        }
      }
      return true;
    }

    function fillBoard(board, row = 0, col = 0) {
      if (row === GRID_SIZE) return true;

      const nextRow = col === GRID_SIZE - 1 ? row + 1 : row;
      const nextCol = col === GRID_SIZE - 1 ? 0 : col + 1;

      if (board[row][col] !== 0) {
        return fillBoard(board, nextRow, nextCol);
      }

      const nums = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
      for (const n of nums) {
        if (isSafe(board, row, col, n)) {
          board[row][col] = n;
          if (fillBoard(board, nextRow, nextCol)) {
            return true;
          }
          board[row][col] = 0;
        }
      }
      return false;
    }

    function copyBoard(board) {
      return board.map(row => row.slice());
    }

    function countSolutions(board, limit = 2) {
      const b = copyBoard(board);
      let count = 0;

      function solve() {
        let row = -1, col = -1;
        outer:
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (b[r][c] === 0) {
              row = r;
              col = c;
              break outer;
            }
          }
        }

        if (row === -1) {
          count++;
          return;
        }

        const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        for (const n of nums) {
          if (isSafe(b, row, col, n)) {
            b[row][col] = n;
            solve();
            if (count >= limit) return;
            b[row][col] = 0;
          }
        }
      }

      solve();
      return count;
    }

    function generateSudoku(maxRemovalsSteps) {
      const solution = createEmptyBoard();
      fillBoard(solution);

      const puzzle = copyBoard(solution);

      const cells = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          cells.push({ r, c });
        }
      }
      shuffle(cells);

      let removals = 0;

      for (const { r, c } of cells) {
        if (puzzle[r][c] === 0) continue;

        const backup = puzzle[r][c];

        const symR = GRID_SIZE - 1 - r;
        const symC = GRID_SIZE - 1 - c;
        const symSame = (symR === r && symC === c);
        const backupSym = puzzle[symR][symC];

        puzzle[r][c] = 0;
        if (!symSame) {
          puzzle[symR][symC] = 0;
        }

        const solutions = countSolutions(puzzle, 2);
        if (solutions !== 1) {
          puzzle[r][c] = backup;
          if (!symSame) {
            puzzle[symR][symC] = backupSym;
          }
        } else {
          removals++;
          if (removals >= maxRemovalsSteps) break;
        }
      }

      return { solution, puzzle };
    }

    // ---------- UI ----------

    function clearSelection() {
      selectedIndex = null;
      document.querySelectorAll(".cell").forEach(c => c.classList.remove("selected"));
    }

    function createGrid() {
      for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 1;
        input.classList.add("cell");
        input.readOnly = true; // inget systemtangentbord

        const row = Math.floor(i / GRID_SIZE);
        const col = i % GRID_SIZE;

        if (row === 2 || row === 5) {
          input.classList.add("box-bottom");
        }
        if (col === 2 || col === 5) {
          input.classList.add("box-right");
        }

        input.id = "cell-" + i;
        input.dataset.index = String(i);
        input.dataset.given = "false";

        input.addEventListener("click", () => {
          const isGiven = input.dataset.given === "true";
          if (isGiven) {
            clearSelection();
            return;
          }
          clearSelection();
          input.classList.add("selected");
          selectedIndex = i;
        });

        gridElement.appendChild(input);
      }
    }

    // R√§kna hur m√•nga av varje siffra som finns och fadas knappar vid >= 9
    function updateKeypadState() {
      const counts = { "1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0 };

      document.querySelectorAll("#sudoku-grid .cell").forEach(input => {
        const v = input.value;
        if (v && counts[v] !== undefined) {
          counts[v]++;
        }
      });

      document.querySelectorAll(".keypad button.num-key").forEach(btn => {
        const num = btn.dataset.num;
        if (counts[num] >= 9) {
          btn.classList.add("disabled");
        } else {
          btn.classList.remove("disabled");
        }
      });
    }

    function renderPuzzle() {
      if (!currentPuzzle) return;
      statusElement.textContent = "";
      clearSelection();

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const index = r * GRID_SIZE + c;
          const input = document.getElementById("cell-" + index);
          const val = currentPuzzle[r][c];

          input.classList.remove("given", "error");
          input.readOnly = true;
          input.dataset.given = val === 0 ? "false" : "true";

          if (val === 0) {
            input.value = "";
          } else {
            input.value = String(val);
            input.classList.add("given");
          }
        }
      }

      updateKeypadState();
    }

    function checkSolution() {
      if (!currentSolution) return;

      let complete = true;
      let correct = true;

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const index = r * GRID_SIZE + c;
          const input = document.getElementById("cell-" + index);
          const expected = String(currentSolution[r][c]);
          const isGiven = input.dataset.given === "true";

          if (isGiven) {
            input.classList.remove("error");
            continue;
          }

          const val = input.value;

          if (val === "") {
            complete = false;
            input.classList.remove("error");
          } else if (val !== expected) {
            correct = false;
            input.classList.add("error");
          } else {
            input.classList.remove("error");
          }
        }
      }

      if (correct && complete) {
        statusElement.textContent = "L√∂sningen st√§mmer ‚Äì bra jobbat! üéâ";
      } else if (!correct) {
        statusElement.textContent = "Det finns fel ‚Äì kolla de r√∂da rutorna.";
      } else {
        statusElement.textContent = "Du √§r p√• god v√§g, men sudokut √§r inte klart √§n.";
      }
    }

    function showSolution() {
      if (!currentSolution) return;

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const index = r * GRID_SIZE + c;
          const input = document.getElementById("cell-" + index);
          input.value = String(currentSolution[r][c]);
          input.readOnly = true;
          input.dataset.given = "true";
          input.classList.remove("error", "selected");
          input.classList.add("given");
        }
      }

      clearSelection();
      updateKeypadState();
      statusElement.textContent = "H√§r √§r l√∂sningen.";
    }

    function generateAndLoadNewSudoku() {
      const diff = getSelectedDifficulty();
      const steps = difficultySettings[diff] ?? difficultySettings.medel;

      statusElement.textContent =
        "Genererar sudoku (" +
        (diff === "latt" ? "l√§tt" : diff === "svar" ? "sv√•r" : "medel") +
        ")...";

      setTimeout(() => {
        const { solution, puzzle } = generateSudoku(steps);
        currentSolution = solution;
        currentPuzzle = puzzle;
        renderPuzzle();
        statusElement.textContent = "";
      }, 10);
    }

    // Siffertangentbord
    keypadElement.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      if (selectedIndex === null) return;

      const input = document.querySelector('input[data-index="' + selectedIndex + '"]');
      if (!input || input.dataset.given === "true") return;

      if (btn.dataset.clear === "true") {
        input.value = "";
        input.classList.remove("error");
      } else if (btn.dataset.num && !btn.classList.contains("disabled")) {
        input.value = btn.dataset.num;
        input.classList.remove("error");
      }

      updateKeypadState();
    });

    // Init
    createGrid();
    generateAndLoadNewSudoku();

    document.getElementById("btn-check").addEventListener("click", checkSolution);
    document.getElementById("btn-solution").addEventListener("click", showSolution);
    document.getElementById("btn-new").addEventListener("click", generateAndLoadNewSudoku);

    document.querySelectorAll('input[name="difficulty"]').forEach(radio => {
      radio.addEventListener("change", generateAndLoadNewSudoku);
    });

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("service-worker.js").catch((err) => {
          console.log("Service worker misslyckades:", err);
        });
      });
    }
  </script>
</body>
</html>
