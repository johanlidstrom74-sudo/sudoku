<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Sudoku</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- PWA / iPhone -->
  <meta name="theme-color" content="#2563eb" />
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(135deg, #eef2ff, #e0f7fa);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app {
      background: #ffffff;
      padding: 16px 20px 20px;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      max-width: 430px;
      width: 100%;
    }

    h1 {
      margin: 0;
      font-size: 1.5rem;
      text-align: center;
    }

    .subtitle {
      margin: 4px 0 0;
      text-align: center;
      font-size: 0.9rem;
      color: #555;
    }

    #sudoku-grid {
      margin: 16px auto;
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
      gap: 2px;
      justify-content: center;
    }

    #sudoku-grid input.cell {
      width: 40px;
      height: 40px;
      text-align: center;
      font-size: 20px;
      border: 1px solid #ccc;
      outline: none;
      border-radius: 4px;
      transition: background 0.15s, border-color 0.15s, box-shadow 0.15s;
    }

    #sudoku-grid input.cell:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
    }

    #sudoku-grid input.cell.given {
      background: #eef3ff;
      font-weight: 600;
      color: #1f2933;
    }

    #sudoku-grid input.cell.error {
      background: #ffe5e5;
      border-color: #f97373;
    }

    #sudoku-grid input.cell.box-bottom {
      border-bottom: 2px solid #111827;
    }

    #sudoku-grid input.cell.box-right {
      border-right: 2px solid #111827;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 8px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #2563eb;
      color: #fff;
      font-weight: 500;
      box-shadow: 0 3px 8px rgba(37, 99, 235, 0.3);
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
    }

    .btn.secondary {
      background: #e5e7eb;
      color: #111827;
      box-shadow: none;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 12px rgba(37, 99, 235, 0.35);
    }

    .btn.secondary:hover {
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 5px rgba(37, 99, 235, 0.25);
    }

    .status {
      margin-top: 10px;
      text-align: center;
      font-size: 0.9rem;
      min-height: 1.2em;
      color: #111827;
    }

    .footer {
      margin-top: 8px;
      text-align: center;
      font-size: 0.75rem;
      color: #6b7280;
    }

    @media (max-width: 480px) {
      #sudoku-grid {
        grid-template-columns: repeat(9, 32px);
        grid-template-rows: repeat(9, 32px);
      }

      #sudoku-grid input.cell {
        width: 32px;
        height: 32px;
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Sudoku</h1>
    <p class="subtitle">Fyll i siffrorna 1‚Äì9 s√• att varje rad, kolumn och 3√ó3-ruta blir komplett.</p>

    <div id="sudoku-grid"></div>

    <div class="controls">
      <button class="btn" id="btn-check">Kontrollera</button>
      <button class="btn secondary" id="btn-new">Ny sudoku</button>
      <button class="btn secondary" id="btn-solution">Visa l√∂sning</button>
    </div>

    <p class="status" id="status"></p>
    <div class="footer">Skapad av dig ü§ç (med lite hj√§lp av ChatGPT)</div>
  </div>

  <script>
    const GRID_SIZE = 9;

    const gridElement = document.getElementById("sudoku-grid");
    const statusElement = document.getElementById("status");

    let currentPuzzle = null;   // 2D-array [9][9]
    let currentSolution = null; // 2D-array [9][9]

    // ---------- Hj√§lpfunktioner f√∂r sudoku ----------

    function createEmptyBoard() {
      return Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function isSafe(board, row, col, num) {
      // Rad
      for (let c = 0; c < GRID_SIZE; c++) {
        if (board[row][c] === num) return false;
      }
      // Kolumn
      for (let r = 0; r < GRID_SIZE; r++) {
        if (board[r][col] === num) return false;
      }
      // 3x3-ruta
      const boxRow = Math.floor(row / 3) * 3;
      const boxCol = Math.floor(col / 3) * 3;
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (board[boxRow + r][boxCol + c] === num) return false;
        }
      }
      return true;
    }

    // Fyller ett tomt br√§de med en komplett, giltig l√∂sning (backtracking)
    function fillBoard(board, row = 0, col = 0) {
      if (row === GRID_SIZE) return true;

      const nextRow = col === GRID_SIZE - 1 ? row + 1 : row;
      const nextCol = col === GRID_SIZE - 1 ? 0 : col + 1;

      if (board[row][col] !== 0) {
        return fillBoard(board, nextRow, nextCol);
      }

      const nums = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
      for (const n of nums) {
        if (isSafe(board, row, col, n)) {
          board[row][col] = n;
          if (fillBoard(board, nextRow, nextCol)) {
            return true;
          }
          board[row][col] = 0;
        }
      }
      return false;
    }

    function copyBoard(board) {
      return board.map(row => row.slice());
    }

    // R√§knar antal l√∂sningar (upp till "limit") f√∂r att testa unik l√∂sning
    function countSolutions(board, limit = 2) {
      const b = copyBoard(board);
      let count = 0;

      function solve() {
        // Hitta f√∂rsta tomma cellen
        let row = -1, col = -1;
        outer:
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (b[r][c] === 0) {
              row = r;
              col = c;
              break outer;
            }
          }
        }

        if (row === -1) {
          count++;
          return;
        }

        const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        for (const n of nums) {
          if (isSafe(b, row, col, n)) {
            b[row][col] = n;
            solve();
            if (count >= limit) return;
            b[row][col] = 0;
          }
        }
      }

      solve();
      return count;
    }

    // Generera sudoku med unik l√∂sning
    function generateSudoku() {
      const solution = createEmptyBoard();
      fillBoard(solution); // fyll med full l√∂sning

      const puzzle = copyBoard(solution);

      // Lista √∂ver alla celler som vi kan f√∂rs√∂ka t√∂mma (f√∂r slump)
      const cells = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          cells.push({ r, c });
        }
      }
      shuffle(cells);

      let removals = 0;
      const maxRemovalsSteps = 30; // ca medel-sv√•r niv√•

      for (const { r, c } of cells) {
        if (puzzle[r][c] === 0) continue;

        const backup = puzzle[r][c];

        // symmetriskt h√•l (f√∂r snyggare m√∂nster)
        const symR = GRID_SIZE - 1 - r;
        const symC = GRID_SIZE - 1 - c;
        const symSame = (symR === r && symC === c);
        const backupSym = puzzle[symR][symC];

        puzzle[r][c] = 0;
        if (!symSame) {
          puzzle[symR][symC] = 0;
        }

        // Kolla om l√∂sningen fortfarande √§r unik
        const solutions = countSolutions(puzzle, 2);
        if (solutions !== 1) {
          // F√∂r m√•nga eller inga l√∂sningar -> backa
          puzzle[r][c] = backup;
          if (!symSame) {
            puzzle[symR][symC] = backupSym;
          }
        } else {
          removals++;
          if (removals >= maxRemovalsSteps) break;
        }
      }

      return { solution, puzzle };
    }

    // ---------- UI / DOM ----------

    function createGrid() {
      for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 1;
        input.classList.add("cell");

        const row = Math.floor(i / GRID_SIZE);
        const col = i % GRID_SIZE;

        if (row === 2 || row === 5) {
          input.classList.add("box-bottom");
        }
        if (col === 2 || col === 5) {
          input.classList.add("box-right");
        }

        input.id = "cell-" + i;

        input.addEventListener("input", (e) => {
          let v = e.target.value.replace(/[^1-9]/g, "");
          e.target.value = v.slice(-1);
        });

        gridElement.appendChild(input);
      }
    }

    function renderPuzzle() {
      if (!currentPuzzle) return;
      statusElement.textContent = "";

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const index = r * GRID_SIZE + c;
          const input = document.getElementById("cell-" + index);
          const val = currentPuzzle[r][c];

          input.classList.remove("given", "error");
          input.readOnly = false;

          if (val === 0) {
            input.value = "";
          } else {
            input.value = String(val);
            input.readOnly = true;
            input.classList.add("given");
          }
        }
      }
    }

    function checkSolution() {
      if (!currentSolution) return;

      let complete = true;
      let correct = true;

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const index = r * GRID_SIZE + c;
          const input = document.getElementById("cell-" + index);
          const expected = String(currentSolution[r][c]);

          if (input.readOnly) {
            input.classList.remove("error");
            continue;
          }

          const val = input.value;

          if (val === "") {
            complete = false;
            input.classList.remove("error");
          } else if (val !== expected) {
            correct = false;
            input.classList.add("error");
          } else {
            input.classList.remove("error");
          }
        }
      }

      if (correct && complete) {
        statusElement.textContent = "L√∂sningen st√§mmer ‚Äì bra jobbat! üéâ";
      } else if (!correct) {
        statusElement.textContent = "Det finns fel ‚Äì kolla de r√∂da rutorna.";
      } else {
        statusElement.textContent = "Du √§r p√• god v√§g, men sudokut √§r inte klart √§n.";
      }
    }

    function showSolution() {
      if (!currentSolution) return;

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const index = r * GRID_SIZE + c;
          const input = document.getElementById("cell-" + index);
          input.value = String(currentSolution[r][c]);
          input.readOnly = true;
          input.classList.remove("error");
          input.classList.add("given");
        }
      }

      statusElement.textContent = "H√§r √§r l√∂sningen.";
    }

    function generateAndLoadNewSudoku() {
      statusElement.textContent = "Genererar sudoku...";
      // Liten timeout f√∂r att texten ska hinna renderas om det tar en liten stund
      setTimeout(() => {
        const { solution, puzzle } = generateSudoku();
        currentSolution = solution;
        currentPuzzle = puzzle;
        renderPuzzle();
        statusElement.textContent = "";
      }, 10);
    }

    // Init
    createGrid();
    generateAndLoadNewSudoku();

    document.getElementById("btn-check").addEventListener("click", checkSolution);
    document.getElementById("btn-solution").addEventListener("click", showSolution);
    document.getElementById("btn-new").addEventListener("click", generateAndLoadNewSudoku);

    // Registrera service worker (f√∂r PWA/offline)
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("service-worker.js").catch((err) => {
          console.log("Service worker misslyckades:", err);
        });
      });
    }
  </script>
</body>
</html>
